// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/reearth/reearth-backend/internal/usecase"
	"github.com/reearth/reearth-backend/pkg/id"
	"golang.org/x/text/language"
)

type Layer interface {
	IsLayer()
}

type Layers interface {
	IsLayers()
}

type Node interface {
	IsNode()
}

type PropertyItem interface {
	IsPropertyItem()
}

type AddDatasetSchemaInput struct {
	SceneID             id.ID  `json:"sceneId"`
	Name                string `json:"name"`
	Representativefield *id.ID `json:"representativefield"`
}

type AddDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type AddDynamicDatasetInput struct {
	DatasetSchemaID id.ID    `json:"datasetSchemaId"`
	Author          string   `json:"author"`
	Content         string   `json:"content"`
	Lat             *float64 `json:"lat"`
	Lng             *float64 `json:"lng"`
	Target          *string  `json:"target"`
}

type AddDynamicDatasetPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
	Dataset       *Dataset       `json:"dataset"`
}

type AddDynamicDatasetSchemaInput struct {
	SceneID id.ID `json:"sceneId"`
}

type AddDynamicDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type AddInfoboxFieldInput struct {
	LayerID     id.ID                `json:"layerId"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
	Index       *int                 `json:"index"`
}

type AddInfoboxFieldPayload struct {
	InfoboxField *InfoboxField `json:"infoboxField"`
	Layer        Layer         `json:"layer"`
}

type AddLayerGroupInput struct {
	ParentLayerID         id.ID                 `json:"parentLayerId"`
	PluginID              *id.PluginID          `json:"pluginId"`
	ExtensionID           *id.PluginExtensionID `json:"extensionId"`
	Index                 *int                  `json:"index"`
	LinkedDatasetSchemaID *id.ID                `json:"linkedDatasetSchemaID"`
	Name                  *string               `json:"name"`
}

type AddLayerGroupPayload struct {
	Layer       *LayerGroup `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index"`
}

type AddLayerItemInput struct {
	ParentLayerID id.ID                `json:"parentLayerId"`
	PluginID      id.PluginID          `json:"pluginId"`
	ExtensionID   id.PluginExtensionID `json:"extensionId"`
	Index         *int                 `json:"index"`
	Name          *string              `json:"name"`
	Lat           *float64             `json:"lat"`
	Lng           *float64             `json:"lng"`
}

type AddLayerItemPayload struct {
	Layer       *LayerItem  `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index"`
}

type AddMemberToTeamInput struct {
	TeamID id.ID `json:"teamId"`
	UserID id.ID `json:"userId"`
	Role   Role  `json:"role"`
}

type AddMemberToTeamPayload struct {
	Team *Team `json:"team"`
}

type AddPropertyItemInput struct {
	PropertyID     id.ID                    `json:"propertyId"`
	SchemaItemID   id.PropertySchemaFieldID `json:"schemaItemId"`
	Index          *int                     `json:"index"`
	NameFieldValue interface{}              `json:"nameFieldValue"`
	NameFieldType  *ValueType               `json:"nameFieldType"`
}

type AddWidgetInput struct {
	SceneID     id.ID                `json:"sceneId"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
}

type AddWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type Asset struct {
	ID          id.ID     `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	TeamID      id.ID     `json:"teamId"`
	Name        string    `json:"name"`
	Size        int64     `json:"size"`
	URL         string    `json:"url"`
	ContentType string    `json:"contentType"`
	Team        *Team     `json:"team"`
}

func (Asset) IsNode() {}

type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	Nodes      []*Asset     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type AssetEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Asset         `json:"node"`
}

type Camera struct {
	Lat      float64 `json:"lat"`
	Lng      float64 `json:"lng"`
	Altitude float64 `json:"altitude"`
	Heading  float64 `json:"heading"`
	Pitch    float64 `json:"pitch"`
	Roll     float64 `json:"roll"`
	Fov      float64 `json:"fov"`
}

type CheckProjectAliasPayload struct {
	Alias     string `json:"alias"`
	Available bool   `json:"available"`
}

type CreateAssetInput struct {
	TeamID id.ID          `json:"teamId"`
	File   graphql.Upload `json:"file"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateInfoboxInput struct {
	LayerID id.ID `json:"layerId"`
}

type CreateInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type CreateProjectInput struct {
	TeamID      id.ID      `json:"teamId"`
	Visualizer  Visualizer `json:"visualizer"`
	Name        *string    `json:"name"`
	Description *string    `json:"description"`
	ImageURL    *url.URL   `json:"imageUrl"`
	Alias       *string    `json:"alias"`
	Archived    *bool      `json:"archived"`
}

type CreateSceneInput struct {
	ProjectID id.ID `json:"projectId"`
}

type CreateScenePayload struct {
	Scene *Scene `json:"scene"`
}

type CreateTeamInput struct {
	Name string `json:"name"`
}

type CreateTeamPayload struct {
	Team *Team `json:"team"`
}

type Dataset struct {
	ID       id.ID           `json:"id"`
	Source   string          `json:"source"`
	SchemaID id.ID           `json:"schemaId"`
	Fields   []*DatasetField `json:"fields"`
	Schema   *DatasetSchema  `json:"schema"`
	Name     *string         `json:"name"`
}

func (Dataset) IsNode() {}

type DatasetConnection struct {
	Edges      []*DatasetEdge `json:"edges"`
	Nodes      []*Dataset     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type DatasetEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Dataset       `json:"node"`
}

type DatasetField struct {
	FieldID  id.ID               `json:"fieldId"`
	SchemaID id.ID               `json:"schemaId"`
	Source   string              `json:"source"`
	Type     ValueType           `json:"type"`
	Value    interface{}         `json:"value"`
	Schema   *DatasetSchema      `json:"schema"`
	Field    *DatasetSchemaField `json:"field"`
	ValueRef *Dataset            `json:"valueRef"`
}

type DatasetSchema struct {
	ID                    id.ID                 `json:"id"`
	Source                string                `json:"source"`
	Name                  string                `json:"name"`
	SceneID               id.ID                 `json:"sceneId"`
	Fields                []*DatasetSchemaField `json:"fields"`
	RepresentativeFieldID *id.ID                `json:"representativeFieldId"`
	Dynamic               *bool                 `json:"dynamic"`
	Datasets              *DatasetConnection    `json:"datasets"`
	Scene                 *Scene                `json:"scene"`
	RepresentativeField   *DatasetSchemaField   `json:"representativeField"`
}

func (DatasetSchema) IsNode() {}

type DatasetSchemaConnection struct {
	Edges      []*DatasetSchemaEdge `json:"edges"`
	Nodes      []*DatasetSchema     `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type DatasetSchemaEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *DatasetSchema `json:"node"`
}

type DatasetSchemaField struct {
	ID       id.ID          `json:"id"`
	Source   string         `json:"source"`
	Name     string         `json:"name"`
	Type     ValueType      `json:"type"`
	SchemaID id.ID          `json:"schemaId"`
	RefID    *id.ID         `json:"refId"`
	Schema   *DatasetSchema `json:"schema"`
	Ref      *DatasetSchema `json:"ref"`
}

func (DatasetSchemaField) IsNode() {}

type DeleteMeInput struct {
	UserID id.ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID id.ID `json:"userId"`
}

type DeleteProjectInput struct {
	ProjectID id.ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID id.ID `json:"projectId"`
}

type DeleteTeamInput struct {
	TeamID id.ID `json:"teamId"`
}

type DeleteTeamPayload struct {
	TeamID id.ID `json:"teamId"`
}

type ImportDatasetFromGoogleSheetInput struct {
	AccessToken     string `json:"accessToken"`
	FileID          string `json:"fileId"`
	SheetName       string `json:"sheetName"`
	SceneID         id.ID  `json:"sceneId"`
	DatasetSchemaID *id.ID `json:"datasetSchemaId"`
}

type ImportDatasetInput struct {
	File            graphql.Upload `json:"file"`
	SceneID         id.ID          `json:"sceneId"`
	DatasetSchemaID *id.ID         `json:"datasetSchemaId"`
}

type ImportDatasetPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type ImportLayerInput struct {
	LayerID id.ID               `json:"layerId"`
	File    graphql.Upload      `json:"file"`
	Format  LayerEncodingFormat `json:"format"`
}

type ImportLayerPayload struct {
	Layers      []Layer     `json:"layers"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type Infobox struct {
	SceneID         id.ID           `json:"sceneId"`
	LayerID         id.ID           `json:"layerId"`
	PropertyID      id.ID           `json:"propertyId"`
	Fields          []*InfoboxField `json:"fields"`
	LinkedDatasetID *id.ID          `json:"linkedDatasetId"`
	Layer           Layer           `json:"layer"`
	Property        *Property       `json:"property"`
	LinkedDataset   *Dataset        `json:"linkedDataset"`
	Merged          *MergedInfobox  `json:"merged"`
	Scene           *Scene          `json:"scene"`
}

type InfoboxField struct {
	ID              id.ID                `json:"id"`
	SceneID         id.ID                `json:"sceneId"`
	LayerID         id.ID                `json:"layerId"`
	PropertyID      id.ID                `json:"propertyId"`
	PluginID        id.PluginID          `json:"pluginId"`
	ExtensionID     id.PluginExtensionID `json:"extensionId"`
	LinkedDatasetID *id.ID               `json:"linkedDatasetId"`
	Layer           Layer                `json:"layer"`
	Infobox         *Infobox             `json:"infobox"`
	Property        *Property            `json:"property"`
	Plugin          *Plugin              `json:"plugin"`
	Extension       *PluginExtension     `json:"extension"`
	LinkedDataset   *Dataset             `json:"linkedDataset"`
	Merged          *MergedInfoboxField  `json:"merged"`
	Scene           *Scene               `json:"scene"`
	ScenePlugin     *ScenePlugin         `json:"scenePlugin"`
}

type InstallPluginInput struct {
	SceneID  id.ID       `json:"sceneId"`
	PluginID id.PluginID `json:"pluginId"`
}

type InstallPluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type LatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type LatLngHeight struct {
	Lat    float64 `json:"lat"`
	Lng    float64 `json:"lng"`
	Height float64 `json:"height"`
}

type LayerGroup struct {
	ID                    id.ID                 `json:"id"`
	SceneID               id.ID                 `json:"sceneId"`
	Name                  string                `json:"name"`
	IsVisible             bool                  `json:"isVisible"`
	PropertyID            *id.ID                `json:"propertyId"`
	PluginID              *id.PluginID          `json:"pluginId"`
	ExtensionID           *id.PluginExtensionID `json:"extensionId"`
	Infobox               *Infobox              `json:"infobox"`
	ParentID              *id.ID                `json:"parentId"`
	LinkedDatasetSchemaID *id.ID                `json:"linkedDatasetSchemaId"`
	Root                  bool                  `json:"root"`
	LayerIds              []*id.ID              `json:"layerIds"`
	Parent                *LayerGroup           `json:"parent"`
	Property              *Property             `json:"property"`
	Plugin                *Plugin               `json:"plugin"`
	Extension             *PluginExtension      `json:"extension"`
	LinkedDatasetSchema   *DatasetSchema        `json:"linkedDatasetSchema"`
	Layers                []Layer               `json:"layers"`
	Scene                 *Scene                `json:"scene"`
	ScenePlugin           *ScenePlugin          `json:"scenePlugin"`
}

func (LayerGroup) IsLayers() {}
func (LayerGroup) IsLayer()  {}

type LayerItem struct {
	ID              id.ID                 `json:"id"`
	SceneID         id.ID                 `json:"sceneId"`
	Name            string                `json:"name"`
	IsVisible       bool                  `json:"isVisible"`
	PropertyID      *id.ID                `json:"propertyId"`
	PluginID        *id.PluginID          `json:"pluginId"`
	ExtensionID     *id.PluginExtensionID `json:"extensionId"`
	Infobox         *Infobox              `json:"infobox"`
	ParentID        *id.ID                `json:"parentId"`
	LinkedDatasetID *id.ID                `json:"linkedDatasetId"`
	Parent          *LayerGroup           `json:"parent"`
	Property        *Property             `json:"property"`
	Plugin          *Plugin               `json:"plugin"`
	Extension       *PluginExtension      `json:"extension"`
	LinkedDataset   *Dataset              `json:"linkedDataset"`
	Merged          *MergedLayer          `json:"merged"`
	Scene           *Scene                `json:"scene"`
	ScenePlugin     *ScenePlugin          `json:"scenePlugin"`
}

func (LayerItem) IsLayers() {}
func (LayerItem) IsLayer()  {}

type LinkDatasetToPropertyValueInput struct {
	PropertyID            id.ID                     `json:"propertyId"`
	SchemaItemID          *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID                *id.ID                    `json:"itemId"`
	FieldID               id.PropertySchemaFieldID  `json:"fieldId"`
	DatasetSchemaIds      []*id.ID                  `json:"datasetSchemaIds"`
	DatasetSchemaFieldIds []*id.ID                  `json:"datasetSchemaFieldIds"`
	DatasetIds            []*id.ID                  `json:"datasetIds"`
}

type MergedInfobox struct {
	SceneID  id.ID                 `json:"sceneID"`
	Property *MergedProperty       `json:"property"`
	Fields   []*MergedInfoboxField `json:"fields"`
	Scene    *Scene                `json:"scene"`
}

type MergedInfoboxField struct {
	OriginalID  id.ID                `json:"originalId"`
	SceneID     id.ID                `json:"sceneID"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
	Property    *MergedProperty      `json:"property"`
	Plugin      *Plugin              `json:"plugin"`
	Extension   *PluginExtension     `json:"extension"`
	Scene       *Scene               `json:"scene"`
	ScenePlugin *ScenePlugin         `json:"scenePlugin"`
}

type MergedLayer struct {
	OriginalID id.ID           `json:"originalId"`
	ParentID   *id.ID          `json:"parentId"`
	SceneID    id.ID           `json:"sceneID"`
	Property   *MergedProperty `json:"property"`
	Infobox    *MergedInfobox  `json:"infobox"`
	Original   *LayerItem      `json:"original"`
	Parent     *LayerGroup     `json:"parent"`
	Scene      *Scene          `json:"scene"`
}

type MergedProperty struct {
	OriginalID      *id.ID                 `json:"originalId"`
	ParentID        *id.ID                 `json:"parentId"`
	SchemaID        *id.PropertySchemaID   `json:"schemaId"`
	LinkedDatasetID *id.ID                 `json:"linkedDatasetId"`
	Original        *Property              `json:"original"`
	Parent          *Property              `json:"parent"`
	Schema          *PropertySchema        `json:"schema"`
	LinkedDataset   *Dataset               `json:"linkedDataset"`
	Groups          []*MergedPropertyGroup `json:"groups"`
}

type MergedPropertyField struct {
	SchemaID    id.PropertySchemaID      `json:"schemaId"`
	FieldID     id.PropertySchemaFieldID `json:"fieldId"`
	Value       interface{}              `json:"value"`
	Type        ValueType                `json:"type"`
	Links       []*PropertyFieldLink     `json:"links"`
	Overridden  bool                     `json:"overridden"`
	Schema      *PropertySchema          `json:"schema"`
	Field       *PropertySchemaField     `json:"field"`
	ActualValue interface{}              `json:"actualValue"`
}

type MergedPropertyGroup struct {
	OriginalPropertyID *id.ID                   `json:"originalPropertyId"`
	ParentPropertyID   *id.ID                   `json:"parentPropertyId"`
	OriginalID         *id.ID                   `json:"originalId"`
	ParentID           *id.ID                   `json:"parentId"`
	SchemaGroupID      id.PropertySchemaFieldID `json:"schemaGroupId"`
	SchemaID           *id.PropertySchemaID     `json:"schemaId"`
	LinkedDatasetID    *id.ID                   `json:"linkedDatasetId"`
	Fields             []*MergedPropertyField   `json:"fields"`
	Groups             []*MergedPropertyGroup   `json:"groups"`
	OriginalProperty   *Property                `json:"originalProperty"`
	ParentProperty     *Property                `json:"parentProperty"`
	Original           *PropertyGroup           `json:"original"`
	Parent             *PropertyGroup           `json:"parent"`
	Schema             *PropertySchema          `json:"schema"`
	LinkedDataset      *Dataset                 `json:"linkedDataset"`
}

type MoveInfoboxFieldInput struct {
	LayerID        id.ID `json:"layerId"`
	InfoboxFieldID id.ID `json:"infoboxFieldId"`
	Index          int   `json:"index"`
}

type MoveInfoboxFieldPayload struct {
	InfoboxFieldID id.ID `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
	Index          int   `json:"index"`
}

type MoveLayerInput struct {
	LayerID     id.ID  `json:"layerId"`
	DestLayerID *id.ID `json:"destLayerId"`
	Index       *int   `json:"index"`
}

type MoveLayerPayload struct {
	LayerID         id.ID       `json:"layerId"`
	FromParentLayer *LayerGroup `json:"fromParentLayer"`
	ToParentLayer   *LayerGroup `json:"toParentLayer"`
	Index           int         `json:"index"`
}

type MovePropertyItemInput struct {
	PropertyID   id.ID                    `json:"propertyId"`
	SchemaItemID id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       id.ID                    `json:"itemId"`
	Index        int                      `json:"index"`
}

type PageInfo struct {
	StartCursor     *usecase.Cursor `json:"startCursor"`
	EndCursor       *usecase.Cursor `json:"endCursor"`
	HasNextPage     bool            `json:"hasNextPage"`
	HasPreviousPage bool            `json:"hasPreviousPage"`
}

type Plugin struct {
	ID                       id.PluginID          `json:"id"`
	Name                     string               `json:"name"`
	Version                  string               `json:"version"`
	Description              string               `json:"description"`
	Author                   string               `json:"author"`
	RepositoryURL            string               `json:"repositoryUrl"`
	PropertySchemaID         *id.PropertySchemaID `json:"propertySchemaId"`
	Extensions               []*PluginExtension   `json:"extensions"`
	ScenePlugin              *ScenePlugin         `json:"scenePlugin"`
	AllTranslatedDescription map[string]string    `json:"allTranslatedDescription"`
	AllTranslatedName        map[string]string    `json:"allTranslatedName"`
	TranslatedName           string               `json:"translatedName"`
	TranslatedDescription    string               `json:"translatedDescription"`
	PropertySchema           *PropertySchema      `json:"propertySchema"`
}

type PluginExtension struct {
	ExtensionID              id.PluginExtensionID `json:"extensionId"`
	PluginID                 id.PluginID          `json:"pluginId"`
	Type                     PluginExtensionType  `json:"type"`
	Name                     string               `json:"name"`
	Description              string               `json:"description"`
	Icon                     string               `json:"icon"`
	Visualizer               Visualizer           `json:"visualizer"`
	PropertySchemaID         id.PropertySchemaID  `json:"propertySchemaId"`
	AllTranslatedName        map[string]string    `json:"allTranslatedName"`
	AllTranslatedDescription map[string]string    `json:"allTranslatedDescription"`
	Plugin                   *Plugin              `json:"plugin"`
	SceneWidget              *SceneWidget         `json:"sceneWidget"`
	PropertySchema           *PropertySchema      `json:"propertySchema"`
	TranslatedName           string               `json:"translatedName"`
	TranslatedDescription    string               `json:"translatedDescription"`
}

type PluginMetadata struct {
	Name         string    `json:"name"`
	Description  string    `json:"description"`
	Author       string    `json:"author"`
	ThumbnailURL string    `json:"thumbnailUrl"`
	CreatedAt    time.Time `json:"createdAt"`
}

type Project struct {
	ID                id.ID             `json:"id"`
	IsArchived        bool              `json:"isArchived"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt"`
	Name              string            `json:"name"`
	Description       string            `json:"description"`
	Alias             string            `json:"alias"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
	ImageURL          *url.URL          `json:"imageUrl"`
	TeamID            id.ID             `json:"teamId"`
	Visualizer        Visualizer        `json:"visualizer"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	Team              *Team             `json:"team"`
	Scene             *Scene            `json:"scene"`
}

func (Project) IsNode() {}

type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	Nodes      []*Project     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type ProjectEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Project       `json:"node"`
}

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type Property struct {
	ID       id.ID               `json:"id"`
	SchemaID id.PropertySchemaID `json:"schemaId"`
	Items    []PropertyItem      `json:"items"`
	Schema   *PropertySchema     `json:"schema"`
	Layer    Layer               `json:"layer"`
	Merged   *MergedProperty     `json:"merged"`
}

func (Property) IsNode() {}

type PropertyCondition struct {
	FieldID id.PropertySchemaFieldID `json:"fieldId"`
	Type    ValueType                `json:"type"`
	Value   interface{}              `json:"value"`
}

type PropertyField struct {
	ID          id.PropertySchemaFieldID `json:"id"`
	ParentID    id.ID                    `json:"parentId"`
	SchemaID    id.PropertySchemaID      `json:"schemaId"`
	FieldID     id.PropertySchemaFieldID `json:"fieldId"`
	Links       []*PropertyFieldLink     `json:"links"`
	Type        ValueType                `json:"type"`
	Value       interface{}              `json:"value"`
	Parent      *Property                `json:"parent"`
	Schema      *PropertySchema          `json:"schema"`
	Field       *PropertySchemaField     `json:"field"`
	ActualValue interface{}              `json:"actualValue"`
}

type PropertyFieldLink struct {
	DatasetID            *id.ID              `json:"datasetId"`
	DatasetSchemaID      id.ID               `json:"datasetSchemaId"`
	DatasetSchemaFieldID id.ID               `json:"datasetSchemaFieldId"`
	Dataset              *Dataset            `json:"dataset"`
	DatasetField         *DatasetField       `json:"datasetField"`
	DatasetSchema        *DatasetSchema      `json:"datasetSchema"`
	DatasetSchemaField   *DatasetSchemaField `json:"datasetSchemaField"`
}

type PropertyFieldPayload struct {
	Property      *Property      `json:"property"`
	PropertyField *PropertyField `json:"propertyField"`
}

type PropertyGroup struct {
	ID            id.ID                    `json:"id"`
	SchemaID      id.PropertySchemaID      `json:"schemaId"`
	SchemaGroupID id.PropertySchemaFieldID `json:"schemaGroupId"`
	Fields        []*PropertyField         `json:"fields"`
	Schema        *PropertySchema          `json:"schema"`
	SchemaGroup   *PropertySchemaGroup     `json:"schemaGroup"`
}

func (PropertyGroup) IsPropertyItem() {}

type PropertyGroupList struct {
	ID            id.ID                    `json:"id"`
	SchemaID      id.PropertySchemaID      `json:"schemaId"`
	SchemaGroupID id.PropertySchemaFieldID `json:"schemaGroupId"`
	Groups        []*PropertyGroup         `json:"groups"`
	Schema        *PropertySchema          `json:"schema"`
	SchemaGroup   *PropertySchemaGroup     `json:"schemaGroup"`
}

func (PropertyGroupList) IsPropertyItem() {}

type PropertyItemPayload struct {
	Property     *Property    `json:"property"`
	PropertyItem PropertyItem `json:"propertyItem"`
}

type PropertyLinkableFields struct {
	SchemaID    id.PropertySchemaID       `json:"schemaId"`
	Latlng      *id.PropertySchemaFieldID `json:"latlng"`
	URL         *id.PropertySchemaFieldID `json:"url"`
	LatlngField *PropertySchemaField      `json:"latlngField"`
	URLField    *PropertySchemaField      `json:"urlField"`
	Schema      *PropertySchema           `json:"schema"`
}

type PropertySchema struct {
	ID             id.PropertySchemaID     `json:"id"`
	Groups         []*PropertySchemaGroup  `json:"groups"`
	LinkableFields *PropertyLinkableFields `json:"linkableFields"`
}

type PropertySchemaField struct {
	FieldID                  id.PropertySchemaFieldID     `json:"fieldId"`
	Type                     ValueType                    `json:"type"`
	Title                    string                       `json:"title"`
	Name                     string                       `json:"name"`
	Description              string                       `json:"description"`
	Prefix                   *string                      `json:"prefix"`
	Suffix                   *string                      `json:"suffix"`
	DefaultValue             interface{}                  `json:"defaultValue"`
	UI                       *PropertySchemaFieldUI       `json:"ui"`
	Min                      *float64                     `json:"min"`
	Max                      *float64                     `json:"max"`
	Choices                  []*PropertySchemaFieldChoice `json:"choices"`
	IsAvailableIf            *PropertyCondition           `json:"isAvailableIf"`
	AllTranslatedTitle       map[string]string            `json:"allTranslatedTitle"`
	AllTranslatedName        map[string]string            `json:"allTranslatedName"`
	AllTranslatedDescription map[string]string            `json:"allTranslatedDescription"`
	TranslatedTitle          string                       `json:"translatedTitle"`
	TranslatedName           string                       `json:"translatedName"`
	TranslatedDescription    string                       `json:"translatedDescription"`
}

type PropertySchemaFieldChoice struct {
	Key                string            `json:"key"`
	Title              string            `json:"title"`
	Label              string            `json:"label"`
	Icon               *string           `json:"icon"`
	AllTranslatedTitle map[string]string `json:"allTranslatedTitle"`
	AllTranslatedLabel map[string]string `json:"allTranslatedLabel"`
	TranslatedTitle    string            `json:"translatedTitle"`
	TranslatedLabel    string            `json:"translatedLabel"`
}

type PropertySchemaGroup struct {
	SchemaGroupID         id.PropertySchemaFieldID  `json:"schemaGroupId"`
	SchemaID              id.PropertySchemaID       `json:"schemaId"`
	Fields                []*PropertySchemaField    `json:"fields"`
	IsList                bool                      `json:"isList"`
	IsAvailableIf         *PropertyCondition        `json:"isAvailableIf"`
	Title                 *string                   `json:"title"`
	AllTranslatedTitle    map[string]string         `json:"allTranslatedTitle"`
	Name                  *id.PropertySchemaFieldID `json:"name"`
	RepresentativeFieldID *id.PropertySchemaFieldID `json:"representativeFieldId"`
	RepresentativeField   *PropertySchemaField      `json:"representativeField"`
	Schema                *PropertySchema           `json:"schema"`
	TranslatedTitle       string                    `json:"translatedTitle"`
}

type PublishProjectInput struct {
	ProjectID id.ID             `json:"projectId"`
	Alias     *string           `json:"alias"`
	Status    PublishmentStatus `json:"status"`
}

type Rect struct {
	West  float64 `json:"west"`
	South float64 `json:"south"`
	East  float64 `json:"east"`
	North float64 `json:"north"`
}

type RemoveAssetInput struct {
	AssetID id.ID `json:"assetId"`
}

type RemoveAssetPayload struct {
	AssetID id.ID `json:"assetId"`
}

type RemoveDatasetSchemaInput struct {
	SchemaID id.ID `json:"schemaId"`
	Force    *bool `json:"force"`
}

type RemoveDatasetSchemaPayload struct {
	SchemaID id.ID `json:"schemaId"`
}

type RemoveInfoboxFieldInput struct {
	LayerID        id.ID `json:"layerId"`
	InfoboxFieldID id.ID `json:"infoboxFieldId"`
}

type RemoveInfoboxFieldPayload struct {
	InfoboxFieldID id.ID `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
}

type RemoveInfoboxInput struct {
	LayerID id.ID `json:"layerId"`
}

type RemoveInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type RemoveLayerInput struct {
	LayerID id.ID `json:"layerId"`
}

type RemoveLayerPayload struct {
	LayerID     id.ID       `json:"layerId"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type RemoveMemberFromTeamInput struct {
	TeamID id.ID `json:"teamId"`
	UserID id.ID `json:"userId"`
}

type RemoveMemberFromTeamPayload struct {
	Team *Team `json:"team"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemovePropertyFieldInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
}

type RemovePropertyItemInput struct {
	PropertyID   id.ID                    `json:"propertyId"`
	SchemaItemID id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       id.ID                    `json:"itemId"`
}

type RemoveWidgetInput struct {
	SceneID     id.ID                `json:"sceneId"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
}

type RemoveWidgetPayload struct {
	Scene       *Scene               `json:"scene"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
}

type Scene struct {
	ID                    id.ID                    `json:"id"`
	ProjectID             id.ID                    `json:"projectId"`
	TeamID                id.ID                    `json:"teamId"`
	PropertyID            id.ID                    `json:"propertyId"`
	CreatedAt             time.Time                `json:"createdAt"`
	UpdatedAt             time.Time                `json:"updatedAt"`
	RootLayerID           id.ID                    `json:"rootLayerId"`
	Widgets               []*SceneWidget           `json:"widgets"`
	Plugins               []*ScenePlugin           `json:"plugins"`
	DynamicDatasetSchemas []*DatasetSchema         `json:"dynamicDatasetSchemas"`
	Project               *Project                 `json:"project"`
	Team                  *Team                    `json:"team"`
	Property              *Property                `json:"property"`
	RootLayer             *LayerGroup              `json:"rootLayer"`
	LockMode              SceneLockMode            `json:"lockMode"`
	DatasetSchemas        *DatasetSchemaConnection `json:"datasetSchemas"`
}

func (Scene) IsNode() {}

type ScenePlugin struct {
	PluginID   id.PluginID `json:"pluginId"`
	PropertyID *id.ID      `json:"propertyId"`
	Plugin     *Plugin     `json:"plugin"`
	Property   *Property   `json:"property"`
}

type SceneWidget struct {
	ID          id.ID                `json:"id"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
	PropertyID  id.ID                `json:"propertyId"`
	Enabled     bool                 `json:"enabled"`
	Plugin      *Plugin              `json:"plugin"`
	Extension   *PluginExtension     `json:"extension"`
	Property    *Property            `json:"property"`
}

type SearchedUser struct {
	UserID    id.ID  `json:"userId"`
	UserName  string `json:"userName"`
	UserEmail string `json:"userEmail"`
}

type SignupInput struct {
	Lang   *language.Tag `json:"lang"`
	Theme  *Theme        `json:"theme"`
	UserID *id.ID        `json:"userId"`
	TeamID *id.ID        `json:"teamId"`
	Secret *string       `json:"secret"`
}

type SignupPayload struct {
	User *User `json:"user"`
	Team *Team `json:"team"`
}

type SyncDatasetInput struct {
	SceneID id.ID  `json:"sceneId"`
	URL     string `json:"url"`
}

type SyncDatasetPayload struct {
	SceneID       id.ID            `json:"sceneId"`
	URL           string           `json:"url"`
	DatasetSchema []*DatasetSchema `json:"datasetSchema"`
	Dataset       []*Dataset       `json:"dataset"`
}

type Team struct {
	ID       id.ID              `json:"id"`
	Name     string             `json:"name"`
	Members  []*TeamMember      `json:"members"`
	Personal bool               `json:"personal"`
	Assets   *AssetConnection   `json:"assets"`
	Projects *ProjectConnection `json:"projects"`
}

func (Team) IsNode() {}

type TeamMember struct {
	UserID id.ID `json:"userId"`
	Role   Role  `json:"role"`
	User   *User `json:"user"`
}

type Typography struct {
	FontFamily *string    `json:"fontFamily"`
	FontWeight *string    `json:"fontWeight"`
	FontSize   *int       `json:"fontSize"`
	Color      *string    `json:"color"`
	TextAlign  *TextAlign `json:"textAlign"`
	Bold       *bool      `json:"bold"`
	Italic     *bool      `json:"italic"`
	Underline  *bool      `json:"underline"`
}

type UninstallPluginInput struct {
	SceneID  id.ID       `json:"sceneId"`
	PluginID id.PluginID `json:"pluginId"`
}

type UninstallPluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type UnlinkPropertyValueInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
}

type UpdateDatasetSchemaInput struct {
	SchemaID id.ID  `json:"schemaId"`
	Name     string `json:"name"`
}

type UpdateDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type UpdateLayerInput struct {
	LayerID id.ID   `json:"layerId"`
	Name    *string `json:"name"`
	Visible *bool   `json:"visible"`
}

type UpdateLayerPayload struct {
	Layer Layer `json:"layer"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name"`
	Email                *string       `json:"email"`
	Lang                 *language.Tag `json:"lang"`
	Theme                *Theme        `json:"theme"`
	Password             *string       `json:"password"`
	PasswordConfirmation *string       `json:"passwordConfirmation"`
}

type UpdateMePayload struct {
	User *User `json:"user"`
}

type UpdateMemberOfTeamInput struct {
	TeamID id.ID `json:"teamId"`
	UserID id.ID `json:"userId"`
	Role   Role  `json:"role"`
}

type UpdateMemberOfTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateProjectInput struct {
	ProjectID         id.ID           `json:"projectId"`
	Name              *string         `json:"name"`
	Description       *string         `json:"description"`
	Archived          *bool           `json:"archived"`
	IsBasicAuthActive *bool           `json:"isBasicAuthActive"`
	BasicAuthUsername *string         `json:"basicAuthUsername"`
	BasicAuthPassword *string         `json:"basicAuthPassword"`
	Alias             *string         `json:"alias"`
	ImageURL          *url.URL        `json:"imageUrl"`
	PublicTitle       *string         `json:"publicTitle"`
	PublicDescription *string         `json:"publicDescription"`
	PublicImage       *graphql.Upload `json:"publicImage"`
	PublicNoIndex     *bool           `json:"publicNoIndex"`
	DeleteImageURL    *bool           `json:"deleteImageUrl"`
	DeletePublicImage *bool           `json:"deletePublicImage"`
}

type UpdatePropertyItemInput struct {
	PropertyID   id.ID                               `json:"propertyId"`
	SchemaItemID id.PropertySchemaFieldID            `json:"schemaItemId"`
	Operations   []*UpdatePropertyItemOperationInput `json:"operations"`
}

type UpdatePropertyItemOperationInput struct {
	Operation      ListOperation `json:"operation"`
	ItemID         *id.ID        `json:"itemId"`
	Index          *int          `json:"index"`
	NameFieldValue interface{}   `json:"nameFieldValue"`
	NameFieldType  *ValueType    `json:"nameFieldType"`
}

type UpdatePropertyValueCameraInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	Lat          float64                   `json:"lat"`
	Lng          float64                   `json:"lng"`
	Altitude     float64                   `json:"altitude"`
	Heading      float64                   `json:"heading"`
	Pitch        float64                   `json:"pitch"`
	Roll         float64                   `json:"roll"`
	Fov          float64                   `json:"fov"`
}

type UpdatePropertyValueInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	Value        interface{}               `json:"value"`
	Type         ValueType                 `json:"type"`
}

type UpdatePropertyValueLatLngHeightInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	Lat          float64                   `json:"lat"`
	Lng          float64                   `json:"lng"`
	Height       float64                   `json:"height"`
}

type UpdatePropertyValueLatLngInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	Lat          float64                   `json:"lat"`
	Lng          float64                   `json:"lng"`
}

type UpdatePropertyValueTypographyInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	FontFamily   *string                   `json:"fontFamily"`
	FontWeight   *string                   `json:"fontWeight"`
	FontSize     *int                      `json:"fontSize"`
	Color        *string                   `json:"color"`
	TextAlign    *TextAlign                `json:"textAlign"`
	Bold         *bool                     `json:"bold"`
	Italic       *bool                     `json:"italic"`
	Underline    *bool                     `json:"underline"`
}

type UpdateTeamInput struct {
	TeamID id.ID  `json:"teamId"`
	Name   string `json:"name"`
}

type UpdateTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateWidgetInput struct {
	SceneID     id.ID                `json:"sceneId"`
	PluginID    id.PluginID          `json:"pluginId"`
	ExtensionID id.PluginExtensionID `json:"extensionId"`
	Enabled     *bool                `json:"enabled"`
}

type UpdateWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type UpgradePluginInput struct {
	SceneID    id.ID       `json:"sceneId"`
	PluginID   id.PluginID `json:"pluginId"`
	ToPluginID id.PluginID `json:"toPluginId"`
}

type UpgradePluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type UploadFileToPropertyInput struct {
	PropertyID   id.ID                     `json:"propertyId"`
	SchemaItemID *id.PropertySchemaFieldID `json:"schemaItemId"`
	ItemID       *id.ID                    `json:"itemId"`
	FieldID      id.PropertySchemaFieldID  `json:"fieldId"`
	File         graphql.Upload            `json:"file"`
}

type UploadPluginInput struct {
	File graphql.Upload `json:"file"`
}

type UploadPluginPayload struct {
	Plugin *Plugin `json:"plugin"`
}

type User struct {
	ID       id.ID        `json:"id"`
	Name     string       `json:"name"`
	Email    string       `json:"email"`
	Lang     language.Tag `json:"lang"`
	Theme    Theme        `json:"theme"`
	MyTeamID id.ID        `json:"myTeamId"`
	Auths    []string     `json:"auths"`
	Teams    []*Team      `json:"teams"`
	MyTeam   *Team        `json:"myTeam"`
}

func (User) IsNode() {}

type LayerEncodingFormat string

const (
	LayerEncodingFormatKml     LayerEncodingFormat = "KML"
	LayerEncodingFormatCzml    LayerEncodingFormat = "CZML"
	LayerEncodingFormatGeojson LayerEncodingFormat = "GEOJSON"
	LayerEncodingFormatShape   LayerEncodingFormat = "SHAPE"
	LayerEncodingFormatReearth LayerEncodingFormat = "REEARTH"
)

var AllLayerEncodingFormat = []LayerEncodingFormat{
	LayerEncodingFormatKml,
	LayerEncodingFormatCzml,
	LayerEncodingFormatGeojson,
	LayerEncodingFormatShape,
	LayerEncodingFormatReearth,
}

func (e LayerEncodingFormat) IsValid() bool {
	switch e {
	case LayerEncodingFormatKml, LayerEncodingFormatCzml, LayerEncodingFormatGeojson, LayerEncodingFormatShape, LayerEncodingFormatReearth:
		return true
	}
	return false
}

func (e LayerEncodingFormat) String() string {
	return string(e)
}

func (e *LayerEncodingFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LayerEncodingFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LayerEncodingFormat", str)
	}
	return nil
}

func (e LayerEncodingFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListOperation string

const (
	ListOperationAdd    ListOperation = "ADD"
	ListOperationMove   ListOperation = "MOVE"
	ListOperationRemove ListOperation = "REMOVE"
)

var AllListOperation = []ListOperation{
	ListOperationAdd,
	ListOperationMove,
	ListOperationRemove,
}

func (e ListOperation) IsValid() bool {
	switch e {
	case ListOperationAdd, ListOperationMove, ListOperationRemove:
		return true
	}
	return false
}

func (e ListOperation) String() string {
	return string(e)
}

func (e *ListOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListOperation", str)
	}
	return nil
}

func (e ListOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeUser           NodeType = "USER"
	NodeTypeTeam           NodeType = "TEAM"
	NodeTypeProject        NodeType = "PROJECT"
	NodeTypePlugin         NodeType = "PLUGIN"
	NodeTypeScene          NodeType = "SCENE"
	NodeTypePropertySchema NodeType = "PROPERTY_SCHEMA"
	NodeTypeProperty       NodeType = "PROPERTY"
	NodeTypeDatasetSchema  NodeType = "DATASET_SCHEMA"
	NodeTypeDataset        NodeType = "DATASET"
	NodeTypeLayerGroup     NodeType = "LAYER_GROUP"
	NodeTypeLayerItem      NodeType = "LAYER_ITEM"
)

var AllNodeType = []NodeType{
	NodeTypeUser,
	NodeTypeTeam,
	NodeTypeProject,
	NodeTypePlugin,
	NodeTypeScene,
	NodeTypePropertySchema,
	NodeTypeProperty,
	NodeTypeDatasetSchema,
	NodeTypeDataset,
	NodeTypeLayerGroup,
	NodeTypeLayerItem,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeUser, NodeTypeTeam, NodeTypeProject, NodeTypePlugin, NodeTypeScene, NodeTypePropertySchema, NodeTypeProperty, NodeTypeDatasetSchema, NodeTypeDataset, NodeTypeLayerGroup, NodeTypeLayerItem:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginExtensionType string

const (
	PluginExtensionTypePrimitive  PluginExtensionType = "PRIMITIVE"
	PluginExtensionTypeWidget     PluginExtensionType = "WIDGET"
	PluginExtensionTypeBlock      PluginExtensionType = "BLOCK"
	PluginExtensionTypeVisualizer PluginExtensionType = "VISUALIZER"
	PluginExtensionTypeInfobox    PluginExtensionType = "INFOBOX"
)

var AllPluginExtensionType = []PluginExtensionType{
	PluginExtensionTypePrimitive,
	PluginExtensionTypeWidget,
	PluginExtensionTypeBlock,
	PluginExtensionTypeVisualizer,
	PluginExtensionTypeInfobox,
}

func (e PluginExtensionType) IsValid() bool {
	switch e {
	case PluginExtensionTypePrimitive, PluginExtensionTypeWidget, PluginExtensionTypeBlock, PluginExtensionTypeVisualizer, PluginExtensionTypeInfobox:
		return true
	}
	return false
}

func (e PluginExtensionType) String() string {
	return string(e)
}

func (e *PluginExtensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginExtensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginExtensionType", str)
	}
	return nil
}

func (e PluginExtensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySchemaFieldUI string

const (
	PropertySchemaFieldUILayer      PropertySchemaFieldUI = "LAYER"
	PropertySchemaFieldUIMultiline  PropertySchemaFieldUI = "MULTILINE"
	PropertySchemaFieldUISelection  PropertySchemaFieldUI = "SELECTION"
	PropertySchemaFieldUIColor      PropertySchemaFieldUI = "COLOR"
	PropertySchemaFieldUIRange      PropertySchemaFieldUI = "RANGE"
	PropertySchemaFieldUIImage      PropertySchemaFieldUI = "IMAGE"
	PropertySchemaFieldUIVideo      PropertySchemaFieldUI = "VIDEO"
	PropertySchemaFieldUIFile       PropertySchemaFieldUI = "FILE"
	PropertySchemaFieldUICameraPose PropertySchemaFieldUI = "CAMERA_POSE"
)

var AllPropertySchemaFieldUI = []PropertySchemaFieldUI{
	PropertySchemaFieldUILayer,
	PropertySchemaFieldUIMultiline,
	PropertySchemaFieldUISelection,
	PropertySchemaFieldUIColor,
	PropertySchemaFieldUIRange,
	PropertySchemaFieldUIImage,
	PropertySchemaFieldUIVideo,
	PropertySchemaFieldUIFile,
	PropertySchemaFieldUICameraPose,
}

func (e PropertySchemaFieldUI) IsValid() bool {
	switch e {
	case PropertySchemaFieldUILayer, PropertySchemaFieldUIMultiline, PropertySchemaFieldUISelection, PropertySchemaFieldUIColor, PropertySchemaFieldUIRange, PropertySchemaFieldUIImage, PropertySchemaFieldUIVideo, PropertySchemaFieldUIFile, PropertySchemaFieldUICameraPose:
		return true
	}
	return false
}

func (e PropertySchemaFieldUI) String() string {
	return string(e)
}

func (e *PropertySchemaFieldUI) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySchemaFieldUI(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySchemaFieldUI", str)
	}
	return nil
}

func (e PropertySchemaFieldUI) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PublishmentStatus string

const (
	PublishmentStatusPublic  PublishmentStatus = "PUBLIC"
	PublishmentStatusLimited PublishmentStatus = "LIMITED"
	PublishmentStatusPrivate PublishmentStatus = "PRIVATE"
)

var AllPublishmentStatus = []PublishmentStatus{
	PublishmentStatusPublic,
	PublishmentStatusLimited,
	PublishmentStatusPrivate,
}

func (e PublishmentStatus) IsValid() bool {
	switch e {
	case PublishmentStatusPublic, PublishmentStatusLimited, PublishmentStatusPrivate:
		return true
	}
	return false
}

func (e PublishmentStatus) String() string {
	return string(e)
}

func (e *PublishmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishmentStatus", str)
	}
	return nil
}

func (e PublishmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleReader Role = "READER"
	RoleWriter Role = "WRITER"
	RoleOwner  Role = "OWNER"
)

var AllRole = []Role{
	RoleReader,
	RoleWriter,
	RoleOwner,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleReader, RoleWriter, RoleOwner:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SceneLockMode string

const (
	SceneLockModeFree            SceneLockMode = "FREE"
	SceneLockModePending         SceneLockMode = "PENDING"
	SceneLockModeDatasetSyncing  SceneLockMode = "DATASET_SYNCING"
	SceneLockModePluginUpgrading SceneLockMode = "PLUGIN_UPGRADING"
	SceneLockModePublishing      SceneLockMode = "PUBLISHING"
)

var AllSceneLockMode = []SceneLockMode{
	SceneLockModeFree,
	SceneLockModePending,
	SceneLockModeDatasetSyncing,
	SceneLockModePluginUpgrading,
	SceneLockModePublishing,
}

func (e SceneLockMode) IsValid() bool {
	switch e {
	case SceneLockModeFree, SceneLockModePending, SceneLockModeDatasetSyncing, SceneLockModePluginUpgrading, SceneLockModePublishing:
		return true
	}
	return false
}

func (e SceneLockMode) String() string {
	return string(e)
}

func (e *SceneLockMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SceneLockMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SceneLockMode", str)
	}
	return nil
}

func (e SceneLockMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TextAlign string

const (
	TextAlignLeft       TextAlign = "LEFT"
	TextAlignCenter     TextAlign = "CENTER"
	TextAlignRight      TextAlign = "RIGHT"
	TextAlignJustify    TextAlign = "JUSTIFY"
	TextAlignJustifyAll TextAlign = "JUSTIFY_ALL"
)

var AllTextAlign = []TextAlign{
	TextAlignLeft,
	TextAlignCenter,
	TextAlignRight,
	TextAlignJustify,
	TextAlignJustifyAll,
}

func (e TextAlign) IsValid() bool {
	switch e {
	case TextAlignLeft, TextAlignCenter, TextAlignRight, TextAlignJustify, TextAlignJustifyAll:
		return true
	}
	return false
}

func (e TextAlign) String() string {
	return string(e)
}

func (e *TextAlign) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TextAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TextAlign", str)
	}
	return nil
}

func (e TextAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Theme string

const (
	ThemeDefault Theme = "DEFAULT"
	ThemeLight   Theme = "LIGHT"
	ThemeDark    Theme = "DARK"
)

var AllTheme = []Theme{
	ThemeDefault,
	ThemeLight,
	ThemeDark,
}

func (e Theme) IsValid() bool {
	switch e {
	case ThemeDefault, ThemeLight, ThemeDark:
		return true
	}
	return false
}

func (e Theme) String() string {
	return string(e)
}

func (e *Theme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Theme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Theme", str)
	}
	return nil
}

func (e Theme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValueType string

const (
	ValueTypeBool         ValueType = "BOOL"
	ValueTypeNumber       ValueType = "NUMBER"
	ValueTypeString       ValueType = "STRING"
	ValueTypeRef          ValueType = "REF"
	ValueTypeURL          ValueType = "URL"
	ValueTypeLatlng       ValueType = "LATLNG"
	ValueTypeLatlngheight ValueType = "LATLNGHEIGHT"
	ValueTypeCamera       ValueType = "CAMERA"
	ValueTypeTypography   ValueType = "TYPOGRAPHY"
	ValueTypeCoordinates  ValueType = "COORDINATES"
	ValueTypePolygon      ValueType = "POLYGON"
	ValueTypeRect         ValueType = "RECT"
)

var AllValueType = []ValueType{
	ValueTypeBool,
	ValueTypeNumber,
	ValueTypeString,
	ValueTypeRef,
	ValueTypeURL,
	ValueTypeLatlng,
	ValueTypeLatlngheight,
	ValueTypeCamera,
	ValueTypeTypography,
	ValueTypeCoordinates,
	ValueTypePolygon,
	ValueTypeRect,
}

func (e ValueType) IsValid() bool {
	switch e {
	case ValueTypeBool, ValueTypeNumber, ValueTypeString, ValueTypeRef, ValueTypeURL, ValueTypeLatlng, ValueTypeLatlngheight, ValueTypeCamera, ValueTypeTypography, ValueTypeCoordinates, ValueTypePolygon, ValueTypeRect:
		return true
	}
	return false
}

func (e ValueType) String() string {
	return string(e)
}

func (e *ValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValueType", str)
	}
	return nil
}

func (e ValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visualizer string

const (
	VisualizerCesium Visualizer = "CESIUM"
)

var AllVisualizer = []Visualizer{
	VisualizerCesium,
}

func (e Visualizer) IsValid() bool {
	switch e {
	case VisualizerCesium:
		return true
	}
	return false
}

func (e Visualizer) String() string {
	return string(e)
}

func (e *Visualizer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visualizer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visualizer", str)
	}
	return nil
}

func (e Visualizer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
